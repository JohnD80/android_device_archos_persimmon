From 94ab16d80dbada129a7b4c5edd9589a4be0bb76e Mon Sep 17 00:00:00 2001
From: olegsvs <oleg.texet@gmail.com>
Date: Wed, 23 Nov 2016 13:30:13 +0000
Subject: [PATCH] mt6735

Change-Id: Ieeab415e3ce0a6b5e2c7df8b792e6c869db8007f
---
 audio_a2dp_hw/audio_a2dp_hw.c      | 20 +++++++++----------
 btif/co/bta_fs_co.c                |  6 +++---
 btif/co/bta_hh_co.c                | 10 +++++-----
 btif/co/bta_hl_co.c                |  2 +-
 btif/co/bta_pan_co.c               | 24 +++++++++++-----------
 btif/include/btif_api.h            | 17 ----------------
 btif/include/btif_pan_internal.h   |  1 -
 btif/include/btif_storage.h        | 12 -----------
 btif/src/bluetooth.c               | 14 ++-----------
 btif/src/btif_config.c             | 21 -------------------
 btif/src/btif_config_util.cpp      |  2 +-
 btif/src/btif_core.c               |  4 ++--
 btif/src/btif_dm.c                 |  4 ++--
 btif/src/btif_hh.c                 | 13 +++---------
 btif/src/btif_hl.c                 | 10 +++++-----
 btif/src/btif_media_task.c         |  2 +-
 btif/src/btif_pan.c                | 26 ++++++++++++------------
 btif/src/btif_rc.c                 | 20 +++++++++----------
 btif/src/btif_sock_rfc.c           | 10 +++++-----
 btif/src/btif_sock_thread.c        | 18 ++++++++---------
 btif/src/btif_sock_util.c          |  6 +++---
 btif/src/btif_storage.c            | 25 -----------------------
 gki/ulinux/gki_ulinux.c            |  6 +++---
 hci/src/btsnoop.c                  |  8 ++++----
 hci/src/btsnoop_net.c              |  6 +++---
 hci/src/userial.c                  |  6 +++---
 hci/src/userial_mct.c              | 10 +++++-----
 hci/src/utils.c                    |  3 +--
 include/bt_target.h                |  4 ++++
 main/bte_logmsg.c                  |  8 ++++----
 osi/src/reactor.c                  |  2 +-
 osi/src/semaphore.c                |  6 +++---
 osi/test/alarm_test.cpp            |  2 +-
 osi/test/reactor_test.cpp          |  2 +-
 stack/bnep/bnep_utils.c            | 11 +++++-----
 stack/btm/btm_int.h                |  5 +++++
 stack/btm/btm_sec.c                | 41 ++++++++++++++++++++++++++++++++++++--
 stack/btu/btu_hcif.c               |  2 +-
 test/blegatt_test/gatt_test.c      |  2 +-
 test/bluedroidtest/bluedroidtest.c |  2 +-
 test/l2test_ertm/l2test_ertm.c     |  2 +-
 test/rfcommtest/rfcommtest.c       |  2 +-
 test/sdptest/sdptool.c             |  2 +-
 test/suite/cases/adapter.c         |  2 +-
 test/suite/main.c                  |  2 +-
 test/suite/support/callbacks.h     |  5 ++---
 udrv/ulinux/uipc.c                 | 18 ++++++++---------
 47 files changed, 188 insertions(+), 238 deletions(-)

diff --git a/audio_a2dp_hw/audio_a2dp_hw.c b/audio_a2dp_hw/audio_a2dp_hw.c
index 6143088..34f6e94 100644
--- a/audio_a2dp_hw/audio_a2dp_hw.c
+++ b/audio_a2dp_hw/audio_a2dp_hw.c
@@ -306,7 +306,7 @@ static int skt_read(int fd, void *p, size_t len)
 
     ts_log("skt_read recv", len, NULL);
 
-    if ((read = TEMP_FAILURE_RETRY(recv(fd, p, len, MSG_NOSIGNAL))) == -1)
+    if ((read = recv(fd, p, len, MSG_NOSIGNAL)) == -1)
     {
         ERROR("write failed with errno=%d\n", errno);
         return -1;
@@ -328,12 +328,12 @@ static int skt_write(int fd, const void *p, size_t len)
     /* poll for 500 ms */
 
     /* send time out */
-    if (TEMP_FAILURE_RETRY(poll(&pfd, 1, 500)) == 0)
+    if (poll(&pfd, 1, 500) == 0)
         return 0;
 
     ts_log("skt_write", len, NULL);
 
-    if ((sent = TEMP_FAILURE_RETRY(send(fd, p, len, MSG_NOSIGNAL))) == -1)
+    if ((sent = send(fd, p, len, MSG_NOSIGNAL)) == -1)
     {
         ERROR("write failed with errno=%d\n", errno);
         return -1;
@@ -364,14 +364,14 @@ static int skt_disconnect(int fd)
 
 static int a2dp_ctrl_receive(struct a2dp_stream_common *common, void* buffer, int length)
 {
-    int ret = TEMP_FAILURE_RETRY(recv(common->ctrl_fd, buffer, length, MSG_NOSIGNAL));
+    int ret = recv(common->ctrl_fd, buffer, length, MSG_NOSIGNAL);
     if (ret < 0)
     {
         ERROR("ack failed (%s)", strerror(errno));
         if (errno == EINTR)
         {
             /* retry again */
-            ret = TEMP_FAILURE_RETRY(recv(common->ctrl_fd, buffer, length, MSG_NOSIGNAL));
+            ret = recv(common->ctrl_fd, buffer, length, MSG_NOSIGNAL);
             if (ret < 0)
             {
                ERROR("ack failed (%s)", strerror(errno));
@@ -398,7 +398,7 @@ static int a2dp_command(struct a2dp_stream_common *common, char cmd)
     INFO("A2DP COMMAND %s", dump_a2dp_ctrl_event(cmd));
 
     /* send command */
-    if (TEMP_FAILURE_RETRY(send(common->ctrl_fd, &cmd, 1, MSG_NOSIGNAL)) == -1) 
+    if (send(common->ctrl_fd, &cmd, 1, MSG_NOSIGNAL) == -1)
     {
         ERROR("cmd failed (%s)", strerror(errno));
         skt_disconnect(common->ctrl_fd);
@@ -475,13 +475,13 @@ static void a2dp_open_ctrl_path(struct a2dp_stream_common *common)
                 break;
 
             ERROR("error : a2dp not ready, wait 250 ms and retry");
-            TEMP_FAILURE_RETRY(usleep(250000));
+            usleep(250000);
             skt_disconnect(common->ctrl_fd);
             common->ctrl_fd = AUDIO_SKT_DISCONNECTED;
         }
 
         /* ctrl channel not ready, wait a bit */
-        TEMP_FAILURE_RETRY(usleep(250000));
+        usleep(250000);
     }
 }
 
@@ -672,7 +672,7 @@ static ssize_t out_write(struct audio_stream_out *stream, const void* buffer,
 
             ERROR("emulate a2dp write delay (%d us)", us_delay);
 
-            TEMP_FAILURE_RETRY(usleep(us_delay));
+            usleep(us_delay);
             pthread_mutex_unlock(&out->common.lock);
             return -1;
         }
@@ -1084,7 +1084,7 @@ static ssize_t in_read(struct audio_stream_in *stream, void* buffer,
 
             DEBUG("emulate a2dp read delay (%d us)", us_delay);
 
-            TEMP_FAILURE_RETRY(usleep(us_delay));
+            usleep(us_delay);
             pthread_mutex_unlock(&in->common.lock);
             return -1;
         }
diff --git a/btif/co/bta_fs_co.c b/btif/co/bta_fs_co.c
index e9b468c..e82fe5b 100644
--- a/btif/co/bta_fs_co.c
+++ b/btif/co/bta_fs_co.c
@@ -345,7 +345,7 @@ void bta_fs_co_open(const char *p_path, int oflags, UINT32 size, UINT16 evt,
 
     if ( 0==err )
     {
-        if ((fd = TEMP_FAILURE_RETRY(open(p_path, oflags | O_NONBLOCK, 0666))) >= 0)
+        if ((fd = open(p_path, oflags | O_NONBLOCK, 0666)) >= 0)
         {
             if (fstat(fd, &file_stat) == 0)
             {
@@ -458,7 +458,7 @@ void bta_fs_co_read(int fd, UINT8 *p_buf, UINT16 nbytes, UINT16 evt, UINT8 ssn,
     int     err;
     UNUSED(ssn);
 
-    if ((num_read = TEMP_FAILURE_RETRY(read (fd, p_buf, nbytes))) < 0)
+    if ((num_read = read (fd, p_buf, nbytes)) < 0)
     {
         err = errno;
         status = BTA_FS_CO_FAIL;
@@ -505,7 +505,7 @@ void bta_fs_co_write(int fd, const UINT8 *p_buf, UINT16 nbytes, UINT16 evt,
     UNUSED(ssn);
     UNUSED(app_id);
 
-    if ((num_written = TEMP_FAILURE_RETRY(write (fd, p_buf, nbytes))) < 0)
+    if ((num_written = write (fd, p_buf, nbytes)) < 0)
     {
         err = errno;
         status = BTA_FS_CO_FAIL;
diff --git a/btif/co/bta_hh_co.c b/btif/co/bta_hh_co.c
index d0475eb..397f893 100644
--- a/btif/co/bta_hh_co.c
+++ b/btif/co/bta_hh_co.c
@@ -172,7 +172,7 @@ static void remove_digitizer_descriptor(UINT8 **data, UINT16 *length)
 static int uhid_write(int fd, const struct uhid_event *ev)
 {
     ssize_t ret;
-    ret = TEMP_FAILURE_RETRY(write(fd, ev, sizeof(*ev)));
+    ret = write(fd, ev, sizeof(*ev));
     if (ret < 0){
         int rtn = -errno;
         APPL_TRACE_ERROR("%s: Cannot write to uhid:%s", __FUNCTION__, strerror(errno));
@@ -197,7 +197,7 @@ static int uhid_event(btif_hh_device_t *p_dev)
         APPL_TRACE_ERROR("%s: Device not found",__FUNCTION__)
         return -1;
     }
-    ret = TEMP_FAILURE_RETRY(read(p_dev->fd, &ev, sizeof(ev)));
+    ret = read(p_dev->fd, &ev, sizeof(ev));
     if (ret == 0) {
         APPL_TRACE_ERROR("%s: Read HUP on uhid-cdev %s", __FUNCTION__,
                                                  strerror(errno));
@@ -298,7 +298,7 @@ static void *btif_hh_poll_event_thread(void *arg)
     pfds[0].events = POLLIN;
 
     while(p_dev->hh_keep_polling){
-        ret = TEMP_FAILURE_RETRY(poll(pfds, 1, 50));
+        ret = poll(pfds, 1, 50);
         if (ret < 0) {
             APPL_TRACE_ERROR("%s: Cannot poll for fds: %s\n", __FUNCTION__, strerror(errno));
             break;
@@ -387,7 +387,7 @@ void bta_hh_co_open(UINT8 dev_handle, UINT8 sub_class, tBTA_HH_ATTR_MASK attr_ma
                                   __FUNCTION__, p_dev->attr_mask, p_dev->sub_class, p_dev->app_id);
 
             if(p_dev->fd<0) {
-                p_dev->fd = TEMP_FAILURE_RETRY(open(dev_path, O_RDWR | O_CLOEXEC));
+                p_dev->fd = open(dev_path, O_RDWR | O_CLOEXEC);
                 if (p_dev->fd < 0){
                     APPL_TRACE_ERROR("%s: Error: failed to open uhid, err:%s",
                                                                     __FUNCTION__,strerror(errno));
@@ -414,7 +414,7 @@ void bta_hh_co_open(UINT8 dev_handle, UINT8 sub_class, tBTA_HH_ATTR_MASK attr_ma
 
                 btif_hh_cb.device_num++;
                 // This is a new device,open the uhid driver now.
-                p_dev->fd = TEMP_FAILURE_RETRY(open(dev_path, O_RDWR | O_CLOEXEC));
+                p_dev->fd = open(dev_path, O_RDWR | O_CLOEXEC);
                 if (p_dev->fd < 0){
                     APPL_TRACE_ERROR("%s: Error: failed to open uhid, err:%s",
                                                                     __FUNCTION__,strerror(errno));
diff --git a/btif/co/bta_hl_co.c b/btif/co/bta_hl_co.c
index f16f218..22b7c89 100644
--- a/btif/co/bta_hl_co.c
+++ b/btif/co/bta_hl_co.c
@@ -385,7 +385,7 @@ void bta_hl_co_put_rx_data (UINT8 app_id, tBTA_HL_MDL_HANDLE mdl_handle,
             {
                 BTIF_TRACE_DEBUG("app_idx=%d mcl_idx=0x%x mdl_idx=0x%x data_size=%d",
                                   app_idx, mcl_idx, mdl_idx, data_size);
-                r = TEMP_FAILURE_RETRY(send(p_dcb->p_scb->socket_id[1], p_dcb->p_rx_pkt, data_size, 0));
+                r = send(p_dcb->p_scb->socket_id[1], p_dcb->p_rx_pkt, data_size, 0);
 
                 if (r == data_size)
                 {
diff --git a/btif/co/bta_pan_co.c b/btif/co/bta_pan_co.c
index 3884abb..7b403f7 100644
--- a/btif/co/bta_pan_co.c
+++ b/btif/co/bta_pan_co.c
@@ -166,18 +166,18 @@ void bta_pan_co_tx_path(UINT16 handle, UINT8 app_id)
     BOOLEAN            ext;
     BOOLEAN         forward;
 
-    BTIF_TRACE_API("%s, handle:%d, app_id:%d", __func__, handle, app_id);
+    BTIF_TRACE_API("bta_pan_co_tx_path, handle:%d, app_id:%d", handle, app_id);
 
     btpan_conn_t* conn = btpan_find_conn_handle(handle);
     if (!conn)
     {
-        BTIF_TRACE_ERROR("%s: cannot find pan connection", __func__);
+        BTIF_TRACE_ERROR("bta_pan_co_tx_path: cannot find pan connection");
         return;
     }
     else if(conn->state != PAN_STATE_OPEN)
     {
-        BTIF_TRACE_ERROR("%s: conn is not opened, conn:%p, conn->state:%d",
-            __func__, conn, conn->state);
+        BTIF_TRACE_ERROR("bta_pan_co_tx_path: conn is not opened, conn:%p, conn->state:%d",
+            conn, conn->state);
         return;
     }
 
@@ -187,16 +187,16 @@ void bta_pan_co_tx_path(UINT16 handle, UINT8 app_id)
         if ((p_buf = bta_pan_ci_readbuf(handle, src, dst, &protocol,
                                  &ext, &forward)))
         {
-            bdstr_t bdstr;
-            BTIF_TRACE_DEBUG("%s, calling btapp_tap_send, "
-                "p_buf->len:%d, offset:%d", __func__, p_buf->len, p_buf->offset);
+            BTIF_TRACE_DEBUG("bta_pan_co_tx_path, calling btapp_tap_send, "
+                "p_buf->len:%d, offset:%d", p_buf->len, p_buf->offset);
             if(is_empty_eth_addr(conn->eth_addr) && is_valid_bt_eth_addr(src))
             {
-                BTIF_TRACE_DEBUG("%s pan bt peer addr: %s", __func__,
-                    bd2str((bt_bdaddr_t *)conn->peer, &bdstr));
-                bd2str((bt_bdaddr_t *)src, &bdstr);
-                BTIF_TRACE_DEBUG("%s:     update its ethernet addr: %s", __func__,
-                    bd2str((bt_bdaddr_t *)src, &bdstr));
+                BTIF_TRACE_DEBUG("pan bt peer addr: %02x:%02x:%02x:%02x:%02x:%02x",
+                    conn->peer[0], conn->peer[1], conn->peer[2],
+                    conn->peer[3],conn->peer[4], conn->peer[5]);
+                BTIF_TRACE_DEBUG("     update its ethernet addr: "
+                    "%02x:%02x:%02x:%02x:%02x:%02x", src[0], src[1], src[2],
+                    src[3],src[4], src[5]);
                 memcpy(conn->eth_addr, src, sizeof(conn->eth_addr));
 
             }
diff --git a/btif/include/btif_api.h b/btif/include/btif_api.h
index 6678d2d..bf17434 100644
--- a/btif/include/btif_api.h
+++ b/btif/include/btif_api.h
@@ -98,23 +98,6 @@ bt_status_t btif_shutdown_bluetooth(void);
 
 /*******************************************************************************
 **
-** Function         is_restricted_mode
-**
-** Description      Checks if BT was enabled in restriced mode. In restricted
-**                  mode, bonds that are created are marked as temporary.
-**                  These bonds persist until we leave restricted mode, at
-**                  which point they will be deleted from the config. Also
-**                  while in restricted mode, the user can access devices
-**                  that are already paired before entering restricted mode,
-**                  but they cannot remove any of these devices.
-**
-** Returns          bool
-**
-*******************************************************************************/
-bool is_restricted_mode(void);
-
-/*******************************************************************************
-**
 ** Function         btif_get_adapter_properties
 **
 ** Description      Fetches all local adapter properties
diff --git a/btif/include/btif_pan_internal.h b/btif/include/btif_pan_internal.h
index fad5577..64bab99 100644
--- a/btif/include/btif_pan_internal.h
+++ b/btif/include/btif_pan_internal.h
@@ -38,7 +38,6 @@
 #define PANU_SERVICE_NAME "Android Network User"
 #define TAP_IF_NAME "bt-pan"
 #define ETH_ADDR_LEN        6
-#define TAP_MAX_PKT_WRITE_LEN 2000
 #ifndef PAN_SECURITY
 #define PAN_SECURITY (BTM_SEC_IN_AUTHENTICATE | BTM_SEC_OUT_AUTHENTICATE | BTM_SEC_IN_ENCRYPT | BTM_SEC_OUT_ENCRYPT)
 #endif
diff --git a/btif/include/btif_storage.h b/btif/include/btif_storage.h
index 4b2c2d9..80ce7e2 100644
--- a/btif/include/btif_storage.h
+++ b/btif/include/btif_storage.h
@@ -355,18 +355,6 @@ BOOLEAN btif_storage_is_fixed_pin_zeros_keyboard(bt_bdaddr_t *remote_bd_addr);
 *******************************************************************************/
 BOOLEAN btif_storage_is_wiimote(bt_bdaddr_t *remote_bd_addr, bt_bdname_t *remote_bd_name);
 
-/*******************************************************************************
-**
-** Function         btif_storage_is_retricted_device
-**
-** Description      BTIF storage API - checks if this device is a restricted device
-**
-** Returns          TRUE  if the device is labled as restricted
-**                  FALSE otherwise
-**
-*******************************************************************************/
-BOOLEAN btif_storage_is_restricted_device(const bt_bdaddr_t *remote_bd_addr);
-
 #if (BLE_INCLUDED == TRUE)
 bt_status_t btif_storage_add_ble_bonding_key( bt_bdaddr_t *remote_bd_addr,
                                               char *key,
diff --git a/btif/src/bluetooth.c b/btif/src/bluetooth.c
index c532b7b..4895e7d 100644
--- a/btif/src/bluetooth.c
+++ b/btif/src/bluetooth.c
@@ -51,7 +51,6 @@
 #include "bt_utils.h"
 #include "l2cdefs.h"
 #include "l2c_api.h"
-#include "btif_storage.h"
 
 #if TEST_APP_INTERFACE == TRUE
 #include <bt_testapp.h>
@@ -100,7 +99,6 @@ typedef struct
 ************************************************************************************/
 
 bt_callbacks_t *bt_hal_cbacks = NULL;
-bool restricted_mode = FALSE;
 
 /** Operating System specific callouts for resource management */
 bt_os_callouts_t *bt_os_callouts = NULL;
@@ -207,11 +205,10 @@ static int initq(bt_callbacks_t* callbacks)
 }
 
 
-static int enable(bool start_restricted) {
+static int enable( void )
+{
     ALOGI("enable");
 
-    restricted_mode = start_restricted;
-
     /* sanity check */
     if (interface_ready() == FALSE)
         return BT_STATUS_NOT_READY;
@@ -241,10 +238,6 @@ static void cleanup( void )
     return;
 }
 
-bool is_restricted_mode() {
-  return restricted_mode;
-}
-
 static void ssrcleanup(void)
 {
     btif_ssr_cleanup();
@@ -360,9 +353,6 @@ static int cancel_bond(const bt_bdaddr_t *bd_addr)
 
 static int remove_bond(const bt_bdaddr_t *bd_addr)
 {
-    if (is_restricted_mode() && !btif_storage_is_restricted_device(bd_addr))
-        return BT_STATUS_SUCCESS;
-
     /* sanity check */
     if (interface_ready() == FALSE)
         return BT_STATUS_NOT_READY;
diff --git a/btif/src/btif_config.c b/btif/src/btif_config.c
index b79ac20..fcc45be 100644
--- a/btif/src/btif_config.c
+++ b/btif/src/btif_config.c
@@ -105,7 +105,6 @@ static int set_node(const char* section, const char* key, const char* name,
 static int save_cfg();
 static void load_cfg();
 static short find_next_node(const cfg_node* p, short start, char* name, int* bytes);
-static void btif_config_remove_restricted();
 #ifdef UNIT_TEST
 static void cfg_test_load();
 static void cfg_test_write();
@@ -149,9 +148,6 @@ int btif_config_init()
             //cfg_test_read();
             exit(0);
         #endif
-
-        if (!is_restricted_mode())
-          btif_config_remove_restricted();
     }
     return pth >= 0;
 }
@@ -999,20 +995,3 @@ static void cfg_test_read()
 
 
 #endif
-
-static void btif_config_remove_restricted() {
-    int section_index = -1;
-    if ((section_index = find_inode(&root, "Remote")) < 0)
-        return;
-
-    cfg_node* remote_node = &root.child[section_index];
-    int count = GET_CHILD_COUNT(remote_node);
-    for (int i = 0; i < count; i ++) {
-        cfg_node* bdaddr_node = &remote_node->child[i];
-        if (find_inode(bdaddr_node, "Restricted") != -1) {
-            free_child(bdaddr_node, 0, GET_CHILD_COUNT(bdaddr_node));
-            free_child(remote_node, i, 1);
-        }
-    }
-}
-
diff --git a/btif/src/btif_config_util.cpp b/btif/src/btif_config_util.cpp
index 0c486df..b293941 100644
--- a/btif/src/btif_config_util.cpp
+++ b/btif/src/btif_config_util.cpp
@@ -401,7 +401,7 @@ static int open_file_map(const char *pathname, const char**map, int* size)
     st.st_size = 0;
     int fd;
     //debug("in");
-    if((fd = TEMP_FAILURE_RETRY(open(pathname, O_RDONLY))) >= 0)
+    if((fd = open(pathname, O_RDONLY)) >= 0)
     {
         //debug("fd:%d", fd);
         if(fstat(fd, &st) == 0 && st.st_size)
diff --git a/btif/src/btif_core.c b/btif/src/btif_core.c
index c209af2..8e8d763 100755
--- a/btif/src/btif_core.c
+++ b/btif/src/btif_core.c
@@ -395,10 +395,10 @@ static void btif_fetch_local_bdaddr(bt_bdaddr_t *local_addr)
 
         BTIF_TRACE_DEBUG("local bdaddr is stored in %s", val);
 
-        if ((addr_fd = TEMP_FAILURE_RETRY(open(val, O_RDONLY))) != -1)
+        if ((addr_fd = open(val, O_RDONLY)) != -1)
         {
             memset(val, 0, sizeof(val));
-            TEMP_FAILURE_RETRY(read(addr_fd, val, FACTORY_BT_BDADDR_STORAGE_LEN));
+            read(addr_fd, val, FACTORY_BT_BDADDR_STORAGE_LEN);
             str2bd(val, local_addr);
             /* If this is not a reserved/special bda, then use it */
             if (memcmp(local_addr->address, null_bdaddr, BD_ADDR_LEN) != 0)
diff --git a/btif/src/btif_dm.c b/btif/src/btif_dm.c
index 19adc22..e320be1 100644
--- a/btif/src/btif_dm.c
+++ b/btif/src/btif_dm.c
@@ -2078,7 +2078,7 @@ static void btif_dm_upstreams_evt(UINT16 event, char* p_param)
             BTIF_TRACE_ERROR("Received H/W Error. ");
             /* Flush storage data */
             btif_config_flush();
-            TEMP_FAILURE_RETRY(usleep(100000)); /* 100milliseconds */
+            usleep(100000); /* 100milliseconds */
             /* Killing the process to force a restart as part of fault tolerance */
             kill(getpid(), SIGKILL);
             break;
@@ -2874,7 +2874,7 @@ bt_status_t btif_dm_pin_reply( const bt_bdaddr_t *bd_addr, uint8_t accept,
                                uint8_t pin_len, bt_pin_code_t *pin_code)
 {
     BTIF_TRACE_EVENT("%s: accept=%d", __FUNCTION__, accept);
-    if (pin_code == NULL || pin_len > PIN_CODE_LEN)
+    if (pin_code == NULL)
         return BT_STATUS_FAIL;
 #if (defined(BLE_INCLUDED) && (BLE_INCLUDED == TRUE))
 
diff --git a/btif/src/btif_hh.c b/btif/src/btif_hh.c
index ca69c3b..93015fd 100644
--- a/btif/src/btif_hh.c
+++ b/btif/src/btif_hh.c
@@ -33,8 +33,6 @@
 
 #define LOG_TAG "BTIF_HH"
 
-#include <cutils/log.h>
-
 #include "bta_api.h"
 #include "bta_hh_api.h"
 #include "bd.h"
@@ -238,7 +236,7 @@ static void toggle_os_keylockstates(int fd, int changedlockstates)
     BTIF_TRACE_DEBUG("%s:  %x %x %x", __FUNCTION__,
          hidreport[6], hidreport[7], hidreport[8]);
     bta_hh_co_write(fd , hidreport, sizeof(hidreport));
-    TEMP_FAILURE_RETRY(usleep(200000));
+    usleep(200000);
     memset(hidreport,0,9);
     hidreport[0]=1;
     BTIF_TRACE_DEBUG("Writing hidreport #2 to os: "\
@@ -260,12 +258,7 @@ static void toggle_os_keylockstates(int fd, int changedlockstates)
 *******************************************************************************/
 static BT_HDR *create_pbuf(UINT16 len, UINT8 *data)
 {
-    UINT16 buflen = (UINT16) (len + BTA_HH_MIN_OFFSET + sizeof(BT_HDR));
-    if (buflen < len) {
-      android_errorWriteWithInfoLog(0x534e4554, "28672558", -1, NULL, 0);
-      return NULL;
-    }
-    BT_HDR* p_buf = GKI_getbuf(buflen);
+    BT_HDR* p_buf = GKI_getbuf((UINT16) (len + BTA_HH_MIN_OFFSET + sizeof(BT_HDR)));
 
     if (p_buf) {
         UINT8* pbuf_data;
@@ -366,7 +359,7 @@ static void sync_lockstate_on_connect(btif_hh_device_t *p_dev)
         BTIF_TRACE_DEBUG("%s: Sending hid report to kernel "\
             "indicating lock key state 0x%x",__FUNCTION__,
             keylockstates);
-        TEMP_FAILURE_RETRY(usleep(200000));
+        usleep(200000);
         toggle_os_keylockstates(p_dev->fd, keylockstates);
     }
     else
diff --git a/btif/src/btif_hl.c b/btif/src/btif_hl.c
index d95776e..9fa08bb 100644
--- a/btif/src/btif_hl.c
+++ b/btif/src/btif_hl.c
@@ -4928,7 +4928,7 @@ static inline int btif_hl_select_wakeup_init(fd_set* set){
 static inline int btif_hl_select_wakeup(void){
     char sig_on = btif_hl_signal_select_wakeup;
     BTIF_TRACE_DEBUG("btif_hl_select_wakeup");
-    return TEMP_FAILURE_RETRY(send(signal_fds[1], &sig_on, sizeof(sig_on), 0));
+    return send(signal_fds[1], &sig_on, sizeof(sig_on), 0);
 }
 
 /*******************************************************************************
@@ -4943,7 +4943,7 @@ static inline int btif_hl_select_wakeup(void){
 static inline int btif_hl_select_close_connected(void){
     char sig_on = btif_hl_signal_select_close_connected;
     BTIF_TRACE_DEBUG("btif_hl_select_close_connected");
-    return TEMP_FAILURE_RETRY(send(signal_fds[1], &sig_on, sizeof(sig_on), 0));
+    return send(signal_fds[1], &sig_on, sizeof(sig_on), 0);
 }
 
 /*******************************************************************************
@@ -4960,7 +4960,7 @@ static inline int btif_hl_close_select_thread(void)
     int result = 0;
     char sig_on = btif_hl_signal_select_exit;
     BTIF_TRACE_DEBUG("btif_hl_signal_select_exit");
-    result = TEMP_FAILURE_RETRY(send(signal_fds[1], &sig_on, sizeof(sig_on), 0));
+    result = send(signal_fds[1], &sig_on, sizeof(sig_on), 0);
     if (btif_is_enabled())
     {
         /* Wait for the select_thread_id to exit if BT is still enabled
@@ -4986,7 +4986,7 @@ static inline int btif_hl_select_wake_reset(void){
     char sig_recv = 0;
 
     BTIF_TRACE_DEBUG("btif_hl_select_wake_reset");
-    TEMP_FAILURE_RETRY(recv(signal_fds[0], &sig_recv, sizeof(sig_recv), MSG_WAITALL));
+    recv(signal_fds[0], &sig_recv, sizeof(sig_recv), MSG_WAITALL);
     return(int)sig_recv;
 }
 /*******************************************************************************
@@ -5047,7 +5047,7 @@ static void *btif_hl_select_thread(void *arg){
         BTIF_TRACE_DEBUG("set curr_set = org_set ");
         curr_set = org_set;
         max_curr_s = max_org_s;
-        int ret = TEMP_FAILURE_RETRY(select((max_curr_s + 1), &curr_set, NULL, NULL, NULL));
+        int ret = select((max_curr_s + 1), &curr_set, NULL, NULL, NULL);
         BTIF_TRACE_DEBUG("select unblocked ret=%d", ret);
         if (ret == -1)
         {
diff --git a/btif/src/btif_media_task.c b/btif/src/btif_media_task.c
index 09c2980..e828dab 100644
--- a/btif/src/btif_media_task.c
+++ b/btif/src/btif_media_task.c
@@ -862,7 +862,7 @@ int btif_a2dp_start_media_task(void)
 
     /* wait for task to come up to sure we are able to send messages to it */
     while (media_task_running == MEDIA_TASK_STATE_OFF)
-        TEMP_FAILURE_RETRY(usleep(10));
+        usleep(10);
 
     APPL_TRACE_EVENT("## A2DP MEDIA TASK STARTED ##");
 
diff --git a/btif/src/btif_pan.c b/btif/src/btif_pan.c
index 44d6e95..bc19f3e 100644
--- a/btif/src/btif_pan.c
+++ b/btif/src/btif_pan.c
@@ -314,7 +314,7 @@ static int tap_if_up(const char *devname, BD_ADDR addr)
     //set mac addr
     memset(&ifr, 0, sizeof(ifr));
     strncpy(ifr.ifr_name, devname, IFNAMSIZ - 1);
-    err = TEMP_FAILURE_RETRY(ioctl(sk, SIOCGIFHWADDR, &ifr));
+    err = ioctl(sk, SIOCGIFHWADDR, &ifr);
     if(err < 0)
     {
         BTIF_TRACE_ERROR("Could not get network hardware for interface:%s, errno:%s", devname, strerror(errno));
@@ -340,7 +340,7 @@ static int tap_if_up(const char *devname, BD_ADDR addr)
         ifr.ifr_hwaddr.sa_data[0] &= ~0x01;
     }
 
-    err = TEMP_FAILURE_RETRY(ioctl(sk, SIOCSIFHWADDR, (caddr_t)&ifr));
+    err = ioctl(sk, SIOCSIFHWADDR, (caddr_t)&ifr);
 
     if (err < 0) {
         BTIF_TRACE_ERROR("Could not set bt address for interface:%s, errno:%s", devname, strerror(errno));
@@ -355,7 +355,7 @@ static int tap_if_up(const char *devname, BD_ADDR addr)
     ifr.ifr_flags |= IFF_UP;
     ifr.ifr_flags |= IFF_MULTICAST;
 
-    err = TEMP_FAILURE_RETRY(ioctl(sk, SIOCSIFFLAGS, (caddr_t) &ifr));
+    err = ioctl(sk, SIOCSIFFLAGS, (caddr_t) &ifr);
 
 
     if (err < 0) {
@@ -380,7 +380,7 @@ static int tap_if_down(const char *devname)
 
     ifr.ifr_flags &= ~IFF_UP;
 
-    err = TEMP_FAILURE_RETRY(ioctl(sk, SIOCSIFFLAGS, (caddr_t) &ifr));
+    err = ioctl(sk, SIOCSIFFLAGS, (caddr_t) &ifr);
 
     close(sk);
 
@@ -407,7 +407,7 @@ int btpan_tap_open()
     /* open the clone device */
 
     //system("insmod /system/lib/modules/tun.ko");
-    if( (fd = TEMP_FAILURE_RETRY(open(clonedev, O_RDWR))) < 0 ) {
+    if( (fd = open(clonedev, O_RDWR)) < 0 ) {
 
         BTIF_TRACE_DEBUG("could not open %s, err:%d", clonedev, errno);
         return fd;
@@ -419,7 +419,7 @@ int btpan_tap_open()
     strncpy(ifr.ifr_name, TAP_IF_NAME, IFNAMSIZ);
 
     /* try to create the device */
-    if( (err = TEMP_FAILURE_RETRY(ioctl(fd, TUNSETIFF, (void *) &ifr))) < 0 )//|| tap_setup_ip(TAP_IF_NAME) == FALSE)
+    if( (err = ioctl(fd, TUNSETIFF, (void *) &ifr)) < 0 )//|| tap_setup_ip(TAP_IF_NAME) == FALSE)
     {
         BTIF_TRACE_DEBUG("ioctl error:%d, errno:%s", err, strerror(errno));
         close(fd);
@@ -428,8 +428,8 @@ int btpan_tap_open()
     BTM_GetLocalDeviceAddr (local_addr);
     if(tap_if_up(TAP_IF_NAME, local_addr) == 0)
     {
-        int flags = TEMP_FAILURE_RETRY(fcntl(fd, F_GETFL, 0));
-        TEMP_FAILURE_RETRY(fcntl(fd, F_SETFL, flags | O_NONBLOCK));
+        int flags = fcntl(fd, F_GETFL, 0);
+        fcntl(fd, F_SETFL, flags | O_NONBLOCK);
         return fd;
     }
     BTIF_TRACE_ERROR("can not bring up tap interface:%s", TAP_IF_NAME);
@@ -451,9 +451,9 @@ int btpan_tap_send(int tap_fd, const BD_ADDR src, const BD_ADDR dst, UINT16 prot
         memcpy(&eth_hdr.h_dest, dst, ETH_ADDR_LEN);
         memcpy(&eth_hdr.h_src, src, ETH_ADDR_LEN);
         eth_hdr.h_proto = htons(proto);
-        char packet[TAP_MAX_PKT_WRITE_LEN + sizeof(tETH_HDR)];
+        char packet[2014];
         memcpy(packet, &eth_hdr, sizeof(tETH_HDR));
-        if (len > TAP_MAX_PKT_WRITE_LEN)
+        if(len > 2000)
         {
             ALOGE("btpan_tap_send eth packet size:%d is exceeded limit!", len);
             return -1;
@@ -463,7 +463,7 @@ int btpan_tap_send(int tap_fd, const BD_ADDR src, const BD_ADDR dst, UINT16 prot
         /* Send data to network interface */
         //btnet_send(btpan_cb.conn[i].sock.sock, &buffer, (len + sizeof(tETH_HDR)));
         //dump_bin("packet to network", packet, len + sizeof(tETH_HDR));
-        int ret = TEMP_FAILURE_RETRY(write(tap_fd, packet, len + sizeof(tETH_HDR)));
+        int ret = write(tap_fd, packet, len + sizeof(tETH_HDR));
         BTIF_TRACE_DEBUG("ret:%d", ret);
         return ret;
     }
@@ -722,7 +722,7 @@ static void btu_exec_tap_fd_read(void *p_param) {
         // We save it in the congest_packet right away in case we can't deliver it in this
         // attempt.
         if (!btpan_cb.congest_packet_size) {
-            ssize_t ret = TEMP_FAILURE_RETRY(read(fd, btpan_cb.congest_packet, sizeof(btpan_cb.congest_packet)));
+            ssize_t ret = read(fd, btpan_cb.congest_packet, sizeof(btpan_cb.congest_packet));
             switch (ret) {
                 case -1:
                     BTIF_TRACE_ERROR("%s unable to read from driver: %s", __func__, strerror(errno));
@@ -766,7 +766,7 @@ static void btu_exec_tap_fd_read(void *p_param) {
         ufd.fd = fd;
         ufd.events = POLLIN;
         ufd.revents = 0;
-        if(TEMP_FAILURE_RETRY(poll(&ufd, 1, 0)) <= 0 || IS_EXCEPTION(ufd.revents))
+        if(poll(&ufd, 1, 0) <= 0 || IS_EXCEPTION(ufd.revents))
             break;
     }
     //add fd back to monitor thread
diff --git a/btif/src/btif_rc.c b/btif/src/btif_rc.c
index 46a54a8..04fec83 100644
--- a/btif/src/btif_rc.c
+++ b/btif/src/btif_rc.c
@@ -281,7 +281,7 @@ int send_event (int fd, uint16_t type, uint16_t code, int32_t value)
     event.code  = code;
     event.value = value;
 
-    return TEMP_FAILURE_RETRY(write(fd, &event, sizeof(event)));
+    return write(fd, &event, sizeof(event));
 }
 
 void send_key (int fd, uint16_t key, int pressed)
@@ -320,7 +320,7 @@ int uinput_create(char *name)
 
     for(x=0; x < MAX_UINPUT_PATHS; x++)
     {
-        fd = TEMP_FAILURE_RETRY(open(uinput_dev_path[x], O_RDWR));
+        fd = open(uinput_dev_path[x], O_RDWR);
         if (fd < 0)
             continue;
         break;
@@ -338,23 +338,23 @@ int uinput_create(char *name)
     dev.id.product = 0x0000;
     dev.id.version = 0x0000;
 
-    if (TEMP_FAILURE_RETRY(write(fd, &dev, sizeof(dev))) < 0) {
+    if (write(fd, &dev, sizeof(dev)) < 0) {
         BTIF_TRACE_ERROR("%s Unable to write device information", __FUNCTION__);
         close(fd);
         return -1;
     }
 
-    TEMP_FAILURE_RETRY(ioctl(fd, UI_SET_EVBIT, EV_KEY));
-    TEMP_FAILURE_RETRY(ioctl(fd, UI_SET_EVBIT, EV_REL));
-    TEMP_FAILURE_RETRY(ioctl(fd, UI_SET_EVBIT, EV_SYN));
+    ioctl(fd, UI_SET_EVBIT, EV_KEY);
+    ioctl(fd, UI_SET_EVBIT, EV_REL);
+    ioctl(fd, UI_SET_EVBIT, EV_SYN);
 
     for (x = 0; key_map[x].name != NULL; x++)
-        TEMP_FAILURE_RETRY(ioctl(fd, UI_SET_KEYBIT, key_map[x].mapped_id));
+        ioctl(fd, UI_SET_KEYBIT, key_map[x].mapped_id);
 
     for(x = 0; x < KEY_MAX; x++)
-        TEMP_FAILURE_RETRY(ioctl(fd, UI_SET_KEYBIT, x));
+        ioctl(fd, UI_SET_KEYBIT, x);
 
-    if (TEMP_FAILURE_RETRY(ioctl(fd, UI_DEV_CREATE, NULL)) < 0) {
+    if (ioctl(fd, UI_DEV_CREATE, NULL) < 0) {
         BTIF_TRACE_ERROR("%s Unable to create uinput device", __FUNCTION__);
         close(fd);
         return -1;
@@ -382,7 +382,7 @@ void close_uinput (void)
 {
     BTIF_TRACE_DEBUG("%s", __FUNCTION__);
     if (uinput_fd > 0) {
-        TEMP_FAILURE_RETRY(ioctl(uinput_fd, UI_DEV_DESTROY));
+        ioctl(uinput_fd, UI_DEV_DESTROY);
 
         close(uinput_fd);
         uinput_fd = -1;
diff --git a/btif/src/btif_sock_rfc.c b/btif/src/btif_sock_rfc.c
index a3e4398..d29f94d 100644
--- a/btif/src/btif_sock_rfc.c
+++ b/btif/src/btif_sock_rfc.c
@@ -993,7 +993,7 @@ static int send_data_to_app(int fd, BT_HDR *p_buf)
 {
     if(p_buf->len == 0)
         return SENT_ALL;
-    int sent = TEMP_FAILURE_RETRY(send(fd, (UINT8 *)(p_buf + 1) + p_buf->offset,  p_buf->len, MSG_DONTWAIT));
+    int sent = send(fd, (UINT8 *)(p_buf + 1) + p_buf->offset,  p_buf->len, MSG_DONTWAIT);
     if(sent == p_buf->len)
         return SENT_ALL;
 
@@ -1066,7 +1066,7 @@ void btsock_rfc_signaled(int fd, int flags, uint32_t user_id)
                     int size = 0;
                     //make sure there's data pending in case the peer closed the socket
                     if(!(flags & SOCK_THREAD_FD_EXCEPTION) ||
-                                (TEMP_FAILURE_RETRY(ioctl(rs->fd, FIONREAD, &size)) == 0 && size))
+                                (ioctl(rs->fd, FIONREAD, &size) == 0 && size))
                     {
                         int rfc_handle = rs->rfc_handle;
                         UINT32 rs_id = rs->id;
@@ -1098,7 +1098,7 @@ void btsock_rfc_signaled(int fd, int flags, uint32_t user_id)
         if(need_close || (flags & SOCK_THREAD_FD_EXCEPTION))
         {
             int size = 0;
-            if(need_close || TEMP_FAILURE_RETRY(ioctl(rs->fd, FIONREAD, &size)) != 0 || size == 0 )
+            if(need_close || ioctl(rs->fd, FIONREAD, &size) != 0 || size == 0 )
             {
                 //cleanup when no data pending
                 APPL_TRACE_DEBUG("SOCK_THREAD_FD_EXCEPTION, cleanup, flags:%x, need_close:%d, pending size:%d",
@@ -1158,7 +1158,7 @@ int bta_co_rfc_data_outgoing_size(void *user_data, int *size)
     rfc_slot_t* rs = find_rfc_slot_by_id(id);
     if(rs)
     {
-        if(TEMP_FAILURE_RETRY(ioctl(rs->fd, FIONREAD, size)) == 0)
+        if(ioctl(rs->fd, FIONREAD, size) == 0)
         {
             APPL_TRACE_DEBUG("ioctl read avaiable size:%d, fd:%d", *size, rs->fd);
             ret = TRUE;
@@ -1181,7 +1181,7 @@ int bta_co_rfc_data_outgoing(void *user_data, UINT8* buf, UINT16 size)
     rfc_slot_t* rs = find_rfc_slot_by_id(id);
     if(rs)
     {
-        int received = TEMP_FAILURE_RETRY(recv(rs->fd, buf, size, 0));
+        int received = recv(rs->fd, buf, size, 0);
         if(received == size)
             ret = TRUE;
         else
diff --git a/btif/src/btif_sock_thread.c b/btif/src/btif_sock_thread.c
index efd0c28..fc19824 100644
--- a/btif/src/btif_sock_thread.c
+++ b/btif/src/btif_sock_thread.c
@@ -116,12 +116,12 @@ static pthread_mutex_t thread_slot_lock;
 static inline void set_socket_blocking(int s, int blocking)
 {
     int opts;
-    opts = TEMP_FAILURE_RETRY(fcntl(s, F_GETFL));
+    opts = fcntl(s, F_GETFL);
     if (opts<0) APPL_TRACE_ERROR("set blocking (%s)", strerror(errno));
     if(blocking)
         opts &= ~O_NONBLOCK;
     else opts |= O_NONBLOCK;
-    TEMP_FAILURE_RETRY(fcntl(s, F_SETFL, opts));
+    fcntl(s, F_SETFL, opts);
 }
 
 static inline int create_server_socket(const char* name)
@@ -158,7 +158,7 @@ static inline int accept_server_socket(int s)
 {
     struct sockaddr_un client_address;
     socklen_t clen;
-    int fd = TEMP_FAILURE_RETRY(accept(s, (struct sockaddr*)&client_address, &clen));
+    int fd = accept(s, (struct sockaddr*)&client_address, &clen);
     APPL_TRACE_DEBUG("accepted fd:%d for server fd:%d", fd, s);
     return fd;
 }
@@ -308,7 +308,7 @@ int btsock_thread_add_fd(int h, int fd, int type, int flags, uint32_t user_id)
     }
     sock_cmd_t cmd = {CMD_ADD_FD, fd, type, flags, user_id};
     APPL_TRACE_DEBUG("adding fd:%d, flags:0x%x", fd, flags);
-    return TEMP_FAILURE_RETRY(send(ts[h].cmd_fdw, &cmd, sizeof(cmd), 0)) == sizeof(cmd);
+    return send(ts[h].cmd_fdw, &cmd, sizeof(cmd), 0) == sizeof(cmd);
 }
 int btsock_thread_post_cmd(int h, int type, const unsigned char* data, int size, uint32_t user_id)
 {
@@ -341,7 +341,7 @@ int btsock_thread_post_cmd(int h, int type, const unsigned char* data, int size,
             return FALSE;
         }
     }
-    return TEMP_FAILURE_RETRY(send(ts[h].cmd_fdw, cmd_send, size_send, 0)) == size_send;
+    return send(ts[h].cmd_fdw, cmd_send, size_send, 0) == size_send;
 }
 int btsock_thread_wakeup(int h)
 {
@@ -356,7 +356,7 @@ int btsock_thread_wakeup(int h)
         return FALSE;
     }
     sock_cmd_t cmd = {CMD_WAKEUP, 0, 0, 0, 0};
-    return TEMP_FAILURE_RETRY(send(ts[h].cmd_fdw, &cmd, sizeof(cmd), 0)) == sizeof(cmd);
+    return send(ts[h].cmd_fdw, &cmd, sizeof(cmd), 0) == sizeof(cmd);
 }
 int btsock_thread_exit(int h)
 {
@@ -371,7 +371,7 @@ int btsock_thread_exit(int h)
         return FALSE;
     }
     sock_cmd_t cmd = {CMD_EXIT, 0, 0, 0, 0};
-    if(TEMP_FAILURE_RETRY(send(ts[h].cmd_fdw, &cmd, sizeof(cmd), 0)) == sizeof(cmd))
+    if(send(ts[h].cmd_fdw, &cmd, sizeof(cmd), 0) == sizeof(cmd))
     {
         pthread_join(ts[h].thread_id, 0);
         lock_slot(&thread_slot_lock);
@@ -466,7 +466,7 @@ static int process_cmd_sock(int h)
 {
     sock_cmd_t cmd = {-1, 0, 0, 0, 0};
     int fd = ts[h].cmd_fdr;
-    if(TEMP_FAILURE_RETRY(recv(fd, &cmd, sizeof(cmd), MSG_WAITALL)) != sizeof(cmd))
+    if(recv(fd, &cmd, sizeof(cmd), MSG_WAITALL) != sizeof(cmd))
     {
         APPL_TRACE_ERROR("recv cmd errno:%d", errno);
         return FALSE;
@@ -563,7 +563,7 @@ static void *sock_poll_thread(void *arg)
     for(;;)
     {
         prepare_poll_fds(h, pfds);
-        int ret = TEMP_FAILURE_RETRY(poll(pfds, ts[h].poll_count, -1));
+        int ret = poll(pfds, ts[h].poll_count, -1);
         if(ret == -1)
         {
             APPL_TRACE_ERROR("poll ret -1, exit the thread, errno:%d, err:%s", errno, strerror(errno));
diff --git a/btif/src/btif_sock_util.c b/btif/src/btif_sock_util.c
index 5fe7d95..8e016e2 100644
--- a/btif/src/btif_sock_util.c
+++ b/btif/src/btif_sock_util.c
@@ -73,7 +73,7 @@ int sock_send_all(int sock_fd, const uint8_t* buf, int len)
     int ret;
     while(s)
     {
-        do ret = TEMP_FAILURE_RETRY(send(sock_fd, buf, s, 0));
+        do ret = send(sock_fd, buf, s, 0);
         while(ret < 0 && errno == EINTR);
         if(ret <= 0)
         {
@@ -91,7 +91,7 @@ int sock_recv_all(int sock_fd, uint8_t* buf, int len)
     int ret = -1;
     while(r)
     {
-        do ret = TEMP_FAILURE_RETRY(recv(sock_fd, buf, r, MSG_WAITALL));
+        do ret = recv(sock_fd, buf, r, MSG_WAITALL);
         while(ret < 0 && errno == EINTR);
         if(ret <= 0)
         {
@@ -139,7 +139,7 @@ int sock_send_fd(int sock_fd, const uint8_t* buf, int len, int send_fd)
         msg.msg_iovlen = 1;
 
         do {
-            ret = TEMP_FAILURE_RETRY(sendmsg(sock_fd, &msg, MSG_NOSIGNAL));
+            ret = sendmsg(sock_fd, &msg, MSG_NOSIGNAL);
         } while (ret < 0 && errno == EINTR);
 
         if (ret < 0) {
diff --git a/btif/src/btif_storage.c b/btif/src/btif_storage.c
index 3e9781b..0623c21 100644
--- a/btif/src/btif_storage.c
+++ b/btif/src/btif_storage.c
@@ -892,13 +892,6 @@ bt_status_t btif_storage_add_bonded_device(bt_bdaddr_t *remote_bd_addr,
     int ret = btif_config_set_int("Remote", bdstr, "LinkKeyType", (int)key_type);
     ret &= btif_config_set_int("Remote", bdstr, "PinLength", (int)pin_length);
     ret &= btif_config_set("Remote", bdstr, "LinkKey", (const char*)link_key, sizeof(LINK_KEY), BTIF_CFG_TYPE_BIN);
-
-    if (is_restricted_mode()) {
-        BTIF_TRACE_WARNING("%s: '%s' pairing will be removed if unrestricted",
-                         __func__, bdstr);
-        btif_config_set_int("Remote", bdstr, "Restricted", 1);
-    }
-
     /* write bonded info immediately */
     btif_config_flush();
     return ret ? BT_STATUS_SUCCESS : BT_STATUS_FAIL;
@@ -2124,21 +2117,3 @@ bt_status_t btif_storage_remove_hidd(bt_bdaddr_t *remote_bd_addr)
 
     return BT_STATUS_SUCCESS;
 }
-
-/*******************************************************************************
-**
-** Function         btif_storage_is_restricted_device
-**
-** Description      BTIF storage API - checks if this device is a restricted device
-**
-** Returns          TRUE  if the device is labeled as restricted
-**                  FALSE otherwise
-**
-*******************************************************************************/
-BOOLEAN btif_storage_is_restricted_device(const bt_bdaddr_t *remote_bd_addr)
-{
-    bdstr_t bdstr;
-    bd2str(remote_bd_addr, &bdstr);
-
-    return btif_config_exist("Remote", bdstr, "Restricted");
-}
diff --git a/gki/ulinux/gki_ulinux.c b/gki/ulinux/gki_ulinux.c
index a940cbe..a31a7a1 100644
--- a/gki/ulinux/gki_ulinux.c
+++ b/gki/ulinux/gki_ulinux.c
@@ -536,7 +536,7 @@ void GKI_destroy_task(UINT8 task_id)
         i = 0;
 
         while ((gki_cb.com.OSWaitEvt[task_id] != 0) && (++i < 10))
-            TEMP_FAILURE_RETRY(usleep(100 * 1000));
+            usleep(100 * 1000);
 #else
         result = pthread_join( gki_cb.os.thread_id[task_id], NULL );
         if ( result < 0 )
@@ -657,7 +657,7 @@ void GKI_shutdown(void)
             i = 0;
 
             while ((gki_cb.com.OSWaitEvt[task_id - 1] != 0) && (++i < 10))
-                TEMP_FAILURE_RETRY(usleep(100 * 1000));
+                usleep(100 * 1000);
 #else
             result = pthread_join( gki_cb.os.thread_id[task_id-1], NULL );
 
@@ -905,7 +905,7 @@ void GKI_delay (UINT32 timeout)
     /* [u]sleep can't be used because it uses SIGALRM */
 
     do {
-        err = TEMP_FAILURE_RETRY(nanosleep(&delay, &delay));
+        err = nanosleep(&delay, &delay);
     } while (err < 0 && errno ==EINTR);
 
     /* Check if task was killed while sleeping */
diff --git a/hci/src/btsnoop.c b/hci/src/btsnoop.c
index 1fc350a..e31af35 100644
--- a/hci/src/btsnoop.c
+++ b/hci/src/btsnoop.c
@@ -66,7 +66,7 @@ static uint64_t btsnoop_timestamp(void) {
 
 static void btsnoop_write(const void *data, size_t length) {
   if (hci_btsnoop_fd != -1)
-    TEMP_FAILURE_RETRY(write(hci_btsnoop_fd, data, length));
+    write(hci_btsnoop_fd, data, length);
 
   btsnoop_net_write(data, length);
 }
@@ -139,16 +139,16 @@ void btsnoop_open(const char *p_path, const bool save_existing) {
     rename(p_path, fname_backup);
   }
 
-  hci_btsnoop_fd = TEMP_FAILURE_RETRY(open(p_path,
+  hci_btsnoop_fd = open(p_path,
                         O_WRONLY | O_CREAT | O_TRUNC,
-                        S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH));
+                        S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH);
 
   if (hci_btsnoop_fd == -1) {
     ALOGE("%s unable to open '%s': %s", __func__, p_path, strerror(errno));
     return;
   }
 
-  TEMP_FAILURE_RETRY(write(hci_btsnoop_fd, "btsnoop\0\0\0\0\1\0\0\x3\xea", 16));
+  write(hci_btsnoop_fd, "btsnoop\0\0\0\0\1\0\0\x3\xea", 16);
 }
 
 void btsnoop_close(void) {
diff --git a/hci/src/btsnoop_net.c b/hci/src/btsnoop_net.c
index 388c91d..adaddcd 100644
--- a/hci/src/btsnoop_net.c
+++ b/hci/src/btsnoop_net.c
@@ -65,7 +65,7 @@ void btsnoop_net_close() {
 void btsnoop_net_write(const void *data, size_t length) {
   pthread_mutex_lock(&client_socket_lock_);
   if (client_socket_ != -1) {
-    if (TEMP_FAILURE_RETRY(send(client_socket_, data, length, 0)) == -1 && errno == ECONNRESET) {
+    if (send(client_socket_, data, length, 0) == -1 && errno == ECONNRESET) {
       safe_close_(&client_socket_);
     }
   }
@@ -104,7 +104,7 @@ static void *listen_fn_(UNUSED_ATTR void *context) {
 
   for (;;) {
     ALOGD("waiting for client connection");
-    int client_socket = TEMP_FAILURE_RETRY(accept(listen_socket_, NULL, NULL));
+    int client_socket = accept(listen_socket_, NULL, NULL);
     if (client_socket == -1) {
       if (errno == EINVAL || errno == EBADF) {
         break;
@@ -119,7 +119,7 @@ static void *listen_fn_(UNUSED_ATTR void *context) {
     pthread_mutex_lock(&client_socket_lock_);
     safe_close_(&client_socket_);
     client_socket_ = client_socket;
-    TEMP_FAILURE_RETRY(send(client_socket_, "btsnoop\0\0\0\0\1\0\0\x3\xea", 16, 0));
+    send(client_socket_, "btsnoop\0\0\0\0\1\0\0\x3\xea", 16, 0);
     pthread_mutex_unlock(&client_socket_lock_);
   }
 
diff --git a/hci/src/userial.c b/hci/src/userial.c
index 26f814f..21cd279 100644
--- a/hci/src/userial.c
+++ b/hci/src/userial.c
@@ -156,7 +156,7 @@ static int select_read(int fd, uint8_t *pbuf, int len)
         fd_max = fd_max > fd ? fd_max : fd;
 
         /* Do the select */
-        n = TEMP_FAILURE_RETRY(select(fd_max+1, &input, NULL, NULL, NULL));
+        n = select(fd_max+1, &input, NULL, NULL, NULL);
         if(is_event_available(&input))
         {
             uint64_t event = read_event();
@@ -172,7 +172,7 @@ static int select_read(int fd, uint8_t *pbuf, int len)
             /* We might have input */
             if (FD_ISSET(fd, &input))
             {
-                ret = TEMP_FAILURE_RETRY(read(fd, pbuf, (size_t)len));
+                ret = read(fd, pbuf, (size_t)len);
                 if (0 == ret)
                     ALOGW( "read() returned 0!" );
 
@@ -366,7 +366,7 @@ uint16_t userial_write(uint16_t msg_id, const uint8_t *p_data, uint16_t len) {
 
     uint16_t total = 0;
     while (len) {
-        ssize_t ret = TEMP_FAILURE_RETRY(write(userial_cb.fd, p_data + total, len));
+        ssize_t ret = write(userial_cb.fd, p_data + total, len);
         switch (ret) {
             case -1:
                 ALOGE("%s error writing to serial port: %s", __func__, strerror(errno));
diff --git a/hci/src/userial_mct.c b/hci/src/userial_mct.c
index 6e15233..2a56ae9 100644
--- a/hci/src/userial_mct.c
+++ b/hci/src/userial_mct.c
@@ -126,12 +126,12 @@ static inline int create_signal_fds(fd_set* set)
 }
 static inline int send_wakeup_signal(char sig_cmd)
 {
-    return TEMP_FAILURE_RETRY(send(signal_fds[1], &sig_cmd, sizeof(sig_cmd), 0));
+    return send(signal_fds[1], &sig_cmd, sizeof(sig_cmd), 0);
 }
 static inline char reset_signal()
 {
     char sig_recv = -1;
-    TEMP_FAILURE_RETRY(recv(signal_fds[0], &sig_recv, sizeof(sig_recv), MSG_WAITALL));
+    recv(signal_fds[0], &sig_recv, sizeof(sig_recv), MSG_WAITALL);
     return sig_recv;
 }
 static inline int is_signaled(fd_set* set)
@@ -176,7 +176,7 @@ static void *userial_read_thread(void *arg)
 
         /* Do the select */
         n = 0;
-        n = TEMP_FAILURE_RETRY(select(fd_max+1, &input, NULL, NULL, NULL));
+        n = select(fd_max+1, &input, NULL, NULL, NULL);
         if(is_signaled(&input))
         {
             reason = reset_signal();
@@ -366,7 +366,7 @@ uint16_t userial_read(uint16_t msg_id, uint8_t *p_buffer, uint16_t len)
     int ret = -1;
     int ch_idx = (msg_id == MSG_HC_TO_STACK_HCI_EVT) ? CH_EVT : CH_ACL_IN;
 
-    ret = TEMP_FAILURE_RETRY(read(userial_cb.fd[ch_idx], p_buffer, (size_t)len));
+    ret = read(userial_cb.fd[ch_idx], p_buffer, (size_t)len);
     if (ret <= 0)
         ALOGW( "userial_read: read() returned %d!", ret);
 
@@ -390,7 +390,7 @@ uint16_t userial_write(uint16_t msg_id, const uint8_t *p_data, uint16_t len)
 
     while(len != 0)
     {
-        ret = TEMP_FAILURE_RETRY(write(userial_cb.fd[ch_idx], p_data+total, len));
+        ret = write(userial_cb.fd[ch_idx], p_data+total, len);
         total += ret;
         len -= ret;
     }
diff --git a/hci/src/utils.c b/hci/src/utils.c
index 0487fa1..9524b4c 100644
--- a/hci/src/utils.c
+++ b/hci/src/utils.c
@@ -28,7 +28,6 @@
 #include <pthread.h>
 #include <utils/Log.h>
 #include <time.h>
-#include <unistd.h>
 #include "bt_hci_bdroid.h"
 #include "utils.h"
 
@@ -276,7 +275,7 @@ void utils_delay (uint32_t timeout)
     ALOGE("utils_delay : %d **", timeout);
     /* [u]sleep can't be used because it uses SIGALRM */
     do {
-        err = TEMP_FAILURE_RETRY(nanosleep(&delay, &delay));
+        err = nanosleep(&delay, &delay);
     } while (err < 0 && errno ==EINTR);
 }
 
diff --git a/include/bt_target.h b/include/bt_target.h
index e4af207..d8964ad 100644
--- a/include/bt_target.h
+++ b/include/bt_target.h
@@ -278,6 +278,10 @@
 #define BTA_AV_RET_TOUT 15
 #endif
 
+#ifndef PORCHE_PAIRING_CONFLICT
+#define PORCHE_PAIRING_CONFLICT  TRUE
+#endif
+
 #ifndef BTA_AV_CO_CP_SCMS_T
 #define BTA_AV_CO_CP_SCMS_T  FALSE
 #endif
diff --git a/main/bte_logmsg.c b/main/bte_logmsg.c
index 05787b6..2afd13a 100644
--- a/main/bte_logmsg.c
+++ b/main/bte_logmsg.c
@@ -273,8 +273,8 @@ LogMsg(UINT32 trace_set_mask, const char *fmt_str, ...)
     LOGI0(bt_layer_tags[trace_layer], buffer);
 #endif
 #else
-	TEMP_FAILURE_RETRY(write(2, buffer, strlen(buffer)));
-	TEMP_FAILURE_RETRY(write(2, "\n", 1));
+	write(2, buffer, strlen(buffer));
+	write(2, "\n", 1);
 #endif
 }
 
@@ -305,8 +305,8 @@ ScrLog(UINT32 trace_set_mask, const char *fmt_str, ...)
 #if (defined(ANDROID_USE_LOGCAT) && (ANDROID_USE_LOGCAT==TRUE))
     LOGI0(bt_layer_tags[trace_layer], buffer);
 #else
-	TEMP_FAILURE_RETRY(write(2, buffer, strlen(buffer)));
-	TEMP_FAILURE_RETRY(write(2, "\n", 1));
+	write(2, buffer, strlen(buffer));
+	write(2, "\n", 1);
 #endif
 }
 
diff --git a/osi/src/reactor.c b/osi/src/reactor.c
index 3c6bca1..e7a3d55 100644
--- a/osi/src/reactor.c
+++ b/osi/src/reactor.c
@@ -163,7 +163,7 @@ static reactor_status_t run_reactor(reactor_t *reactor, int iterations, struct t
 
     int ret;
     do {
-      ret = TEMP_FAILURE_RETRY(select(max_fd + 1, &read_set, &write_set, NULL, tv));
+      ret = select(max_fd + 1, &read_set, &write_set, NULL, tv);
     } while (ret == -1 && errno == EINTR);
 
     if (ret == -1) {
diff --git a/osi/src/semaphore.c b/osi/src/semaphore.c
index 9413569..c1d038a 100644
--- a/osi/src/semaphore.c
+++ b/osi/src/semaphore.c
@@ -67,12 +67,12 @@ bool semaphore_try_wait(semaphore_t *semaphore) {
   assert(semaphore != NULL);
   assert(semaphore->fd != -1);
 
-  int flags = TEMP_FAILURE_RETRY(fcntl(semaphore->fd, F_GETFL));
+  int flags = fcntl(semaphore->fd, F_GETFL);
   if (flags == -1) {
     ALOGE("%s unable to get flags for semaphore fd: %s", __func__, strerror(errno));
     return false;
   }
-  if (TEMP_FAILURE_RETRY(fcntl(semaphore->fd, F_SETFL, flags | O_NONBLOCK)) == -1) {
+  if (fcntl(semaphore->fd, F_SETFL, flags | O_NONBLOCK) == -1) {
     ALOGE("%s unable to set O_NONBLOCK for semaphore fd: %s", __func__, strerror(errno));
     return false;
   }
@@ -81,7 +81,7 @@ bool semaphore_try_wait(semaphore_t *semaphore) {
   if (eventfd_read(semaphore->fd, &value) == -1)
     return false;
 
-  if (TEMP_FAILURE_RETRY(fcntl(semaphore->fd, F_SETFL, flags)) == -1)
+  if (fcntl(semaphore->fd, F_SETFL, flags) == -1)
     ALOGE("%s unable to resetore flags for semaphore fd: %s", __func__, strerror(errno));
   return true;
 }
diff --git a/osi/test/alarm_test.cpp b/osi/test/alarm_test.cpp
index c4caddc..d08cf6d 100644
--- a/osi/test/alarm_test.cpp
+++ b/osi/test/alarm_test.cpp
@@ -20,7 +20,7 @@ static void *saved_data;
 static const uint64_t EPSILON_MS = 5;
 
 static void msleep(uint64_t ms) {
-  TEMP_FAILURE_RETRY(usleep(ms * 1000));
+  usleep(ms * 1000);
 }
 
 static void timer_callback(void *) {
diff --git a/osi/test/reactor_test.cpp b/osi/test/reactor_test.cpp
index ce00468..4a9fb21 100644
--- a/osi/test/reactor_test.cpp
+++ b/osi/test/reactor_test.cpp
@@ -79,7 +79,7 @@ TEST(ReactorTest, reactor_start_wait_stop) {
   reactor_t *reactor = reactor_new();
 
   spawn_reactor_thread(reactor);
-  TEMP_FAILURE_RETRY(usleep(50 * 1000));
+  usleep(50 * 1000);
   EXPECT_TRUE(thread_running);
 
   reactor_stop(reactor);
diff --git a/stack/bnep/bnep_utils.c b/stack/bnep/bnep_utils.c
index 116d80f..ad879db 100644
--- a/stack/bnep/bnep_utils.c
+++ b/stack/bnep/bnep_utils.c
@@ -173,11 +173,10 @@ void bnep_send_conn_req (tBNEP_CONN *p_bcb)
     BT_HDR  *p_buf;
     UINT8   *p, *p_start;
 
-    BNEP_TRACE_DEBUG ("%s: sending setup req with dst uuid %x",
-        __func__, p_bcb->dst_uuid.uu.uuid16);
+    BNEP_TRACE_DEBUG ("BNEP sending setup req with dst uuid %x", p_bcb->dst_uuid.uu.uuid16);
     if ((p_buf = (BT_HDR *)GKI_getpoolbuf (BNEP_POOL_ID)) == NULL)
     {
-        BNEP_TRACE_ERROR ("%s: not able to send connection request", __func__);
+        BNEP_TRACE_ERROR ("BNEP - not able to send connection request");
         return;
     }
 
@@ -210,12 +209,12 @@ void bnep_send_conn_req (tBNEP_CONN *p_bcb)
         memcpy (p, p_bcb->src_uuid.uu.uuid128, p_bcb->dst_uuid.len);
         p += p_bcb->dst_uuid.len;
     }
-#endif
     else
     {
-        BNEP_TRACE_ERROR ("%s: uuid: %x, invalid length: %x",
-            __func__, p_bcb->dst_uuid.uu.uuid16, p_bcb->dst_uuid.len);
+        BNEP_TRACE_ERROR ("BNEP: uuid: %x, invalid length: %x", p_bcb->dst_uuid.uu.uuid16,
+            p_bcb->dst_uuid.len);
     }
+#endif
 
     p_buf->len = (UINT16)(p - p_start);
 
diff --git a/stack/btm/btm_int.h b/stack/btm/btm_int.h
index 16b5cfc..c407b69 100644
--- a/stack/btm/btm_int.h
+++ b/stack/btm/btm_int.h
@@ -910,6 +910,11 @@ typedef struct
     BOOLEAN                  security_mode_changed;  /* mode changed during bonding */
     BOOLEAN                  pin_type_changed;       /* pin type changed during bonding */
     BOOLEAN                  sec_req_pending;       /*   TRUE if a request is pending */
+// btla-specific ++
+#ifdef PORCHE_PAIRING_CONFLICT
+    UINT8                    pin_code_len_saved;     /* for legacy devices */
+#endif
+// btla-specific --
 
     UINT8                    pin_code_len;  /* for legacy devices */
     PIN_CODE                 pin_code;      /* for legacy devices */
diff --git a/stack/btm/btm_sec.c b/stack/btm/btm_sec.c
index f9d83fe..4fc6d75 100644
--- a/stack/btm/btm_sec.c
+++ b/stack/btm/btm_sec.c
@@ -1087,6 +1087,13 @@ void BTM_PINCodeReply (BD_ADDR bd_addr, UINT8 res, UINT8 pin_len, UINT8 *p_pin,
     btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);
     btm_cb.acl_disc_reason = HCI_SUCCESS;
 
+#ifdef PORCHE_PAIRING_CONFLICT
+    BTM_TRACE_EVENT("BTM_PINCodeReply(): Saving pin_len: %d btm_cb.pin_code_len: %d", pin_len, btm_cb.pin_code_len);
+    /* if this was not pre-fetched, save the PIN */
+    if (btm_cb.pin_code_len == 0)
+        memcpy (btm_cb.pin_code, p_pin, pin_len);
+    btm_cb.pin_code_len_saved = pin_len;
+#endif
     btsnd_hcic_pin_code_req_reply (bd_addr, pin_len, p_pin);
 }
 
@@ -5183,15 +5190,40 @@ void btm_sec_pin_code_request (UINT8 *p_bda)
         if ( (memcmp (p_bda, btm_cb.pairing_bda, BD_ADDR_LEN) == 0)  &&
              (btm_cb.pairing_state == BTM_PAIR_STATE_WAIT_AUTH_COMPLETE) )
         {
-             btsnd_hcic_pin_code_neg_reply (p_bda);
-             return;
+             /* fake this out - porshe carkit issue - */
+//            btm_cb.pairing_state = BTM_PAIR_STATE_IDLE;
+             if(! btm_cb.pin_code_len_saved)
+             {
+                 btsnd_hcic_pin_code_neg_reply (p_bda);
+                 return;
+             }
+             else
+             {
+                 btsnd_hcic_pin_code_req_reply (p_bda, btm_cb.pin_code_len_saved, p_cb->pin_code);
+      	         return;
+             }
         }
         else if ((btm_cb.pairing_state != BTM_PAIR_STATE_WAIT_PIN_REQ)
                  || memcmp (p_bda, btm_cb.pairing_bda, BD_ADDR_LEN) != 0)
         {
             BTM_TRACE_WARNING ("btm_sec_pin_code_request() rejected - state: %s",
                                 btm_pair_state_descr(btm_cb.pairing_state));
+
+#ifdef PORCHE_PAIRING_CONFLICT
+            /* reply pin code again due to counter in_rand when local initiates pairing */
+            BTM_TRACE_EVENT ("btm_sec_pin_code_request from remote dev. for local initiated pairing");
+            if(! btm_cb.pin_code_len_saved)
+            {
+                btsnd_hcic_pin_code_neg_reply (p_bda);
+            }
+            else
+            {
+                btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);
+                btsnd_hcic_pin_code_req_reply (p_bda, btm_cb.pin_code_len_saved, p_cb->pin_code);
+            }
+#else
             btsnd_hcic_pin_code_neg_reply (p_bda);
+#endif
             return;
         }
     }
@@ -5228,6 +5260,10 @@ void btm_sec_pin_code_request (UINT8 *p_bda)
         BTM_TRACE_EVENT ("btm_sec_pin_code_request bonding sending reply");
         btsnd_hcic_pin_code_req_reply (p_bda, btm_cb.pin_code_len, p_cb->pin_code);
 
+#ifdef PORCHE_PAIRING_CONFLICT
+        btm_cb.pin_code_len_saved = btm_cb.pin_code_len;
+#endif
+
         /* Mark that we forwarded received from the user PIN code */
         btm_cb.pin_code_len = 0;
 
@@ -5258,6 +5294,7 @@ void btm_sec_pin_code_request (UINT8 *p_bda)
     /* Notify upper layer of PIN request and start expiration timer */
     else
     {
+        btm_cb.pin_code_len_saved = 0;
         btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_LOCAL_PIN);
         /* Pin code request can not come at the same time as connection request */
         memcpy (p_cb->connecting_bda, p_bda, BD_ADDR_LEN);
diff --git a/stack/btu/btu_hcif.c b/stack/btu/btu_hcif.c
index ffba726..8bf95a1 100644
--- a/stack/btu/btu_hcif.c
+++ b/stack/btu/btu_hcif.c
@@ -1707,7 +1707,7 @@ void btu_hcif_cmd_timeout (UINT8 controller_id)
         HCI_TRACE_ERROR("Num consecutive HCI Cmd tout =%d Restarting BT process",num_hci_cmds_timed_out);
 
         bte_ssr_cleanup();
-        TEMP_FAILURE_RETRY(usleep(20000)); /* 20 milliseconds */
+        usleep(20000); /* 20 milliseconds */
         /* Killing the process to force a restart as part of fault tolerance */
         kill(getpid(), SIGKILL);
     }
diff --git a/test/blegatt_test/gatt_test.c b/test/blegatt_test/gatt_test.c
index e2f02b7..cc01960 100644
--- a/test/blegatt_test/gatt_test.c
+++ b/test/blegatt_test/gatt_test.c
@@ -1119,7 +1119,7 @@ void bdt_enable(void)
         bdt_log("Bluetooth is already enabled");
         return;
     }
-    status = sBtInterface->enable(false);
+    status = sBtInterface->enable();
 
     check_return_status(status);
 }
diff --git a/test/bluedroidtest/bluedroidtest.c b/test/bluedroidtest/bluedroidtest.c
index a9cb7b4..1345348 100644
--- a/test/bluedroidtest/bluedroidtest.c
+++ b/test/bluedroidtest/bluedroidtest.c
@@ -596,7 +596,7 @@ void bdt_enable(void)
         bdt_log("Bluetooth is already enabled");
         return;
     }
-    status = sBtInterface->enable(false);
+    status = sBtInterface->enable();
 
     check_return_status(status);
 }
diff --git a/test/l2test_ertm/l2test_ertm.c b/test/l2test_ertm/l2test_ertm.c
index 6834de4..b3f1178 100644
--- a/test/l2test_ertm/l2test_ertm.c
+++ b/test/l2test_ertm/l2test_ertm.c
@@ -642,7 +642,7 @@ void bdt_enable(void)
         printf("Bluetooth is already enabled\n");
         return;
     }
-    status = sBtInterface->enable(false);
+    status = sBtInterface->enable();
     return;
 }
 
diff --git a/test/rfcommtest/rfcommtest.c b/test/rfcommtest/rfcommtest.c
index 5253546..e95f305 100644
--- a/test/rfcommtest/rfcommtest.c
+++ b/test/rfcommtest/rfcommtest.c
@@ -678,7 +678,7 @@ void bdt_enable(void)
         bdt_log("Bluetooth is already enabled");
         return;
     }
-    status = sBtInterface->enable(false);
+    status = sBtInterface->enable();
 
     check_return_status(status);
 }
diff --git a/test/sdptest/sdptool.c b/test/sdptest/sdptool.c
index 8530a51..03673bc 100644
--- a/test/sdptest/sdptool.c
+++ b/test/sdptest/sdptool.c
@@ -539,7 +539,7 @@ void bdt_enable(void)
         printf("\nBluetooth is already enabled\n");
         return;
     }
-    status = sBtInterface->enable(false);
+    status = sBtInterface->enable();
     return;
 }
 
diff --git a/test/suite/cases/adapter.c b/test/suite/cases/adapter.c
index 9834618..4053b88 100644
--- a/test/suite/cases/adapter.c
+++ b/test/suite/cases/adapter.c
@@ -24,7 +24,7 @@
 bool adapter_enable_disable() {
   int error;
 
-  CALL_AND_WAIT(error = bt_interface->enable(false), adapter_state_changed);
+  CALL_AND_WAIT(error = bt_interface->enable(), adapter_state_changed);
   TASSERT(error == BT_STATUS_SUCCESS, "Error enabling Bluetooth: %d", error);
   TASSERT(adapter_get_state() == BT_STATE_ON, "Adapter did not turn on.");
 
diff --git a/test/suite/main.c b/test/suite/main.c
index f09d8b4..7a3af5b 100644
--- a/test/suite/main.c
+++ b/test/suite/main.c
@@ -89,7 +89,7 @@ int main(int argc, char **argv) {
   // Run the full test suite.
   for (size_t i = 0; i < test_suite_size; ++i) {
     callbacks_init();
-    CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);
+    CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);
     if (test_suite[i].function()) {
       printf("[%4d] %-64s [%sPASS%s]\n", ++case_num, test_suite[i].function_name, GREEN, GRAY);
       ++pass;
diff --git a/test/suite/support/callbacks.h b/test/suite/support/callbacks.h
index f7627fd..102e13f 100644
--- a/test/suite/support/callbacks.h
+++ b/test/suite/support/callbacks.h
@@ -21,12 +21,11 @@
 #include "base.h"
 
 #include <semaphore.h>
-#include <unistd.h>
 
 #define WAIT(callback) \
   do { \
     sem_t *semaphore = callbacks_get_semaphore(#callback); \
-    TEMP_FAILURE_RETRY(sem_wait(semaphore)); \
+    sem_wait(semaphore); \
   } while (0)
 
 #define CALL_AND_WAIT(expression, callback) \
@@ -34,7 +33,7 @@
     sem_t *semaphore = callbacks_get_semaphore(#callback); \
     while (!sem_trywait(semaphore)); \
     expression; \
-    TEMP_FAILURE_RETRY(sem_wait(semaphore)); \
+    sem_wait(semaphore); \
   } while(0)
 
 // To be called from every exit point of the callback. This macro
diff --git a/udrv/ulinux/uipc.c b/udrv/ulinux/uipc.c
index 7c9224c..62864e8 100644
--- a/udrv/ulinux/uipc.c
+++ b/udrv/ulinux/uipc.c
@@ -183,7 +183,7 @@ static int accept_server_socket(int sfd)
     pfd.fd = sfd;
     pfd.events = POLLIN;
 
-    if (TEMP_FAILURE_RETRY(poll(&pfd, 1, 0)) == 0)
+    if (poll(&pfd, 1, 0) == 0)
     {
         BTIF_TRACE_EVENT("accept poll timeout");
         return -1;
@@ -191,7 +191,7 @@ static int accept_server_socket(int sfd)
 
     //BTIF_TRACE_EVENT("poll revents 0x%x", pfd.revents);
 
-    if ((fd = TEMP_FAILURE_RETRY(accept(sfd, (struct sockaddr *)&remote, &len))) == -1)
+    if ((fd = accept(sfd, (struct sockaddr *)&remote, &len)) == -1)
     {
          BTIF_TRACE_ERROR("sock accept failed (%s)", strerror(errno));
          return -1;
@@ -328,7 +328,7 @@ static void uipc_check_interrupt_locked(void)
     {
         char sig_recv = 0;
         //BTIF_TRACE_EVENT("UIPC INTERRUPT");
-        TEMP_FAILURE_RETRY(recv(uipc_main.signal_fds[0], &sig_recv, sizeof(sig_recv), MSG_WAITALL));
+        recv(uipc_main.signal_fds[0], &sig_recv, sizeof(sig_recv), MSG_WAITALL);
     }
 }
 
@@ -336,7 +336,7 @@ static inline void uipc_wakeup_locked(void)
 {
     char sig_on = 1;
     BTIF_TRACE_EVENT("UIPC SEND WAKE UP");
-    TEMP_FAILURE_RETRY(send(uipc_main.signal_fds[1], &sig_on, sizeof(sig_on), 0));
+    send(uipc_main.signal_fds[1], &sig_on, sizeof(sig_on), 0);
 }
 
 static int uipc_setup_server_locked(tUIPC_CH_ID ch_id, char *name, tUIPC_RCV_CBACK *cback)
@@ -393,7 +393,7 @@ static void uipc_flush_ch_locked(tUIPC_CH_ID ch_id)
 
     while (1)
     {
-        ret = TEMP_FAILURE_RETRY(poll(&pfd, 1, 1));
+        ret = poll(&pfd, 1, 1);
         BTIF_TRACE_VERBOSE("%s() - polling fd %d, revents: 0x%x, ret %d",
                 __FUNCTION__, pfd.fd, pfd.revents, ret);
 
@@ -516,7 +516,7 @@ static void uipc_read_task(void *arg)
     {
         uipc_main.read_set = uipc_main.active_set;
 
-        result = TEMP_FAILURE_RETRY(select(uipc_main.max_fd+1, &uipc_main.read_set, NULL, NULL, NULL));
+        result = select(uipc_main.max_fd+1, &uipc_main.read_set, NULL, NULL, NULL);
 
         if (result == 0)
         {
@@ -727,7 +727,7 @@ UDRV_API BOOLEAN UIPC_Send(tUIPC_CH_ID ch_id, UINT16 msg_evt, UINT8 *p_buf,
 
     UIPC_LOCK();
 
-    if (TEMP_FAILURE_RETRY(write(uipc_main.ch[ch_id].fd, p_buf, msglen)) < 0)
+    if (write(uipc_main.ch[ch_id].fd, p_buf, msglen) < 0)
     {
         BTIF_TRACE_ERROR("failed to write (%s)", strerror(errno));
     }
@@ -796,7 +796,7 @@ UDRV_API UINT32 UIPC_Read(tUIPC_CH_ID ch_id, UINT16 *p_msg_evt, UINT8 *p_buf, UI
 
         /* make sure there is data prior to attempting read to avoid blocking
            a read for more than poll timeout */
-        if (TEMP_FAILURE_RETRY(poll(&pfd, 1, uipc_main.ch[ch_id].read_poll_tmo_ms)) == 0)
+        if (poll(&pfd, 1, uipc_main.ch[ch_id].read_poll_tmo_ms) == 0)
         {
             BTIF_TRACE_EVENT("poll timeout (%d ms)", uipc_main.ch[ch_id].read_poll_tmo_ms);
             break;
@@ -813,7 +813,7 @@ UDRV_API UINT32 UIPC_Read(tUIPC_CH_ID ch_id, UINT16 *p_msg_evt, UINT8 *p_buf, UI
             return 0;
         }
 
-        n = TEMP_FAILURE_RETRY(recv(fd, p_buf+n_read, len-n_read, 0));
+        n = recv(fd, p_buf+n_read, len-n_read, 0);
 
         //BTIF_TRACE_EVENT("read %d bytes", n);
 
-- 
1.9.1

